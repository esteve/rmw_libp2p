/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_allocator_s {
    pub allocate: ::std::option::Option<
        unsafe extern "C" fn(
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub deallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            state: *mut ::std::os::raw::c_void,
        ),
    >,
    pub reallocate: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            size: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub zero_allocate: ::std::option::Option<
        unsafe extern "C" fn(
            number_of_elements: usize,
            size_of_element: usize,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub state: *mut ::std::os::raw::c_void,
}
pub type rcutils_allocator_t = rcutils_allocator_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_string_array_s {
    pub size: usize,
    pub data: *mut *mut ::std::os::raw::c_char,
    pub allocator: rcutils_allocator_t,
}
pub type rcutils_string_array_t = rcutils_string_array_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcutils_uint8_array_s {
    pub buffer: *mut u8,
    pub buffer_length: usize,
    pub buffer_capacity: usize,
    pub allocator: rcutils_allocator_t,
}
pub type rcutils_uint8_array_t = rcutils_uint8_array_s;
pub type rosidl_message_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_message_type_support_t {
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_void,
    pub func: rosidl_message_typesupport_handle_function,
}
pub type rosidl_service_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_service_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_service_type_support_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_service_type_support_t {
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_void,
    pub func: rosidl_service_typesupport_handle_function,
}
pub type rosidl_runtime_c__bound_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_runtime_c__Sequence__bound,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_runtime_c__Sequence__bound,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__Sequence__bound {
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_void,
    pub func: rosidl_runtime_c__bound_handle_function,
}
pub type rcutils_time_point_value_t = i64;
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_DEFAULT: rmw_localhost_only_e = 0;
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_ENABLED: rmw_localhost_only_e = 1;
pub const rmw_localhost_only_e_RMW_LOCALHOST_ONLY_DISABLED: rmw_localhost_only_e = 2;
pub type rmw_localhost_only_e = ::std::os::raw::c_uint;
pub use self::rmw_localhost_only_e as rmw_localhost_only_t;
pub type rmw_ret_t = i32;
pub const rmw_security_enforcement_policy_e_RMW_SECURITY_ENFORCEMENT_PERMISSIVE:
    rmw_security_enforcement_policy_e = 0;
pub const rmw_security_enforcement_policy_e_RMW_SECURITY_ENFORCEMENT_ENFORCE:
    rmw_security_enforcement_policy_e = 1;
pub type rmw_security_enforcement_policy_e = ::std::os::raw::c_uint;
pub use self::rmw_security_enforcement_policy_e as rmw_security_enforcement_policy_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_security_options_s {
    pub enforce_security: rmw_security_enforcement_policy_t,
    pub security_root_path: *mut ::std::os::raw::c_char,
}
pub type rmw_security_options_t = rmw_security_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_impl_s {
    _unused: [u8; 0],
}
pub type rmw_init_options_impl_t = rmw_init_options_impl_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_init_options_s {
    pub instance_id: u64,
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub domain_id: usize,
    pub security_options: rmw_security_options_t,
    pub localhost_only: rmw_localhost_only_t,
    pub enclave: *mut ::std::os::raw::c_char,
    pub allocator: rcutils_allocator_t,
    pub impl_: *mut rmw_init_options_impl_t,
}
pub type rmw_init_options_t = rmw_init_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_impl_s {
    _unused: [u8; 0],
}
pub type rmw_context_impl_t = rmw_context_impl_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_context_s {
    pub instance_id: u64,
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub options: rmw_init_options_t,
    pub actual_domain_id: usize,
    pub impl_: *mut rmw_context_impl_t,
}
pub type rmw_context_t = rmw_context_s;
pub type rmw_serialized_message_t = rcutils_uint8_array_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_content_filter_options_s {
    pub filter_expression: *mut ::std::os::raw::c_char,
    pub expression_parameters: rcutils_string_array_t,
}
pub type rmw_subscription_content_filter_options_t = rmw_subscription_content_filter_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_time_s {
    pub sec: u64,
    pub nsec: u64,
}
pub type rmw_time_t = rmw_time_s;
pub type rmw_time_point_value_t = rcutils_time_point_value_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_node_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_char,
    pub namespace_: *const ::std::os::raw::c_char,
    pub context: *mut rmw_context_t,
}
pub type rmw_node_t = rmw_node_s;
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 0 ;
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 1 ;
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED : rmw_unique_network_flow_endpoints_requirement_e = 2 ;
pub const rmw_unique_network_flow_endpoints_requirement_e_RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT : rmw_unique_network_flow_endpoints_requirement_e = 3 ;
pub type rmw_unique_network_flow_endpoints_requirement_e = ::std::os::raw::c_uint;
pub use self::rmw_unique_network_flow_endpoints_requirement_e as rmw_unique_network_flow_endpoints_requirement_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_options_s {
    pub rmw_specific_publisher_payload: *mut ::std::os::raw::c_void,
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
}
pub type rmw_publisher_options_t = rmw_publisher_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub topic_name: *const ::std::os::raw::c_char,
    pub options: rmw_publisher_options_t,
    pub can_loan_messages: bool,
}
pub type rmw_publisher_t = rmw_publisher_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_options_s {
    pub rmw_specific_subscription_payload: *mut ::std::os::raw::c_void,
    pub ignore_local_publications: bool,
    pub require_unique_network_flow_endpoints: rmw_unique_network_flow_endpoints_requirement_t,
    pub content_filter_options: *mut rmw_subscription_content_filter_options_t,
}
pub type rmw_subscription_options_t = rmw_subscription_options_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub topic_name: *const ::std::os::raw::c_char,
    pub options: rmw_subscription_options_t,
    pub can_loan_messages: bool,
    pub is_cft_enabled: bool,
}
pub type rmw_subscription_t = rmw_subscription_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_service_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub service_name: *const ::std::os::raw::c_char,
}
pub type rmw_service_t = rmw_service_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_client_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub service_name: *const ::std::os::raw::c_char,
}
pub type rmw_client_t = rmw_client_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_condition_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub context: *mut rmw_context_t,
}
pub type rmw_guard_condition_t = rmw_guard_condition_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_publisher_allocation_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
pub type rmw_publisher_allocation_t = rmw_publisher_allocation_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscription_allocation_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
pub type rmw_subscription_allocation_t = rmw_subscription_allocation_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_subscriptions_s {
    pub subscriber_count: usize,
    pub subscribers: *mut *mut ::std::os::raw::c_void,
}
pub type rmw_subscriptions_t = rmw_subscriptions_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_services_s {
    pub service_count: usize,
    pub services: *mut *mut ::std::os::raw::c_void,
}
pub type rmw_services_t = rmw_services_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_clients_s {
    pub client_count: usize,
    pub clients: *mut *mut ::std::os::raw::c_void,
}
pub type rmw_clients_t = rmw_clients_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_events_s {
    pub event_count: usize,
    pub events: *mut *mut ::std::os::raw::c_void,
}
pub type rmw_events_t = rmw_events_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_guard_conditions_s {
    pub guard_condition_count: usize,
    pub guard_conditions: *mut *mut ::std::os::raw::c_void,
}
pub type rmw_guard_conditions_t = rmw_guard_conditions_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_wait_set_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub guard_conditions: *mut rmw_guard_conditions_t,
    pub data: *mut ::std::os::raw::c_void,
}
pub type rmw_wait_set_t = rmw_wait_set_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_request_id_s {
    pub writer_guid: [i8; 16usize],
    pub sequence_number: i64,
}
pub type rmw_request_id_t = rmw_request_id_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_service_info_s {
    pub source_timestamp: rmw_time_point_value_t,
    pub received_timestamp: rmw_time_point_value_t,
    pub request_id: rmw_request_id_t,
}
pub type rmw_service_info_t = rmw_service_info_s;
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT:
    rmw_qos_reliability_policy_e = 0;
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_RELIABLE:
    rmw_qos_reliability_policy_e = 1;
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT:
    rmw_qos_reliability_policy_e = 2;
pub const rmw_qos_reliability_policy_e_RMW_QOS_POLICY_RELIABILITY_UNKNOWN:
    rmw_qos_reliability_policy_e = 3;
pub type rmw_qos_reliability_policy_e = ::std::os::raw::c_uint;
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT: rmw_qos_history_policy_e =
    0;
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_KEEP_LAST: rmw_qos_history_policy_e = 1;
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_KEEP_ALL: rmw_qos_history_policy_e = 2;
pub const rmw_qos_history_policy_e_RMW_QOS_POLICY_HISTORY_UNKNOWN: rmw_qos_history_policy_e = 3;
pub type rmw_qos_history_policy_e = ::std::os::raw::c_uint;
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT:
    rmw_qos_durability_policy_e = 0;
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL:
    rmw_qos_durability_policy_e = 1;
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_VOLATILE:
    rmw_qos_durability_policy_e = 2;
pub const rmw_qos_durability_policy_e_RMW_QOS_POLICY_DURABILITY_UNKNOWN:
    rmw_qos_durability_policy_e = 3;
pub type rmw_qos_durability_policy_e = ::std::os::raw::c_uint;
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT:
    rmw_qos_liveliness_policy_e = 0;
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_AUTOMATIC:
    rmw_qos_liveliness_policy_e = 1;
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE:
    rmw_qos_liveliness_policy_e = 2;
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC:
    rmw_qos_liveliness_policy_e = 3;
pub const rmw_qos_liveliness_policy_e_RMW_QOS_POLICY_LIVELINESS_UNKNOWN:
    rmw_qos_liveliness_policy_e = 4;
pub type rmw_qos_liveliness_policy_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_qos_profile_s {
    pub history: rmw_qos_history_policy_e,
    pub depth: usize,
    pub reliability: rmw_qos_reliability_policy_e,
    pub durability: rmw_qos_durability_policy_e,
    pub deadline: rmw_time_s,
    pub lifespan: rmw_time_s,
    pub liveliness: rmw_qos_liveliness_policy_e,
    pub liveliness_lease_duration: rmw_time_s,
    pub avoid_ros_namespace_conventions: bool,
}
pub type rmw_qos_profile_t = rmw_qos_profile_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_gid_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: [u8; 24usize],
}
pub type rmw_gid_t = rmw_gid_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_info_s {
    pub source_timestamp: rmw_time_point_value_t,
    pub received_timestamp: rmw_time_point_value_t,
    pub publication_sequence_number: u64,
    pub reception_sequence_number: u64,
    pub publisher_gid: rmw_gid_t,
    pub from_intra_process: bool,
}
pub type rmw_message_info_t = rmw_message_info_s;
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_DEBUG: rmw_log_severity_t = 10;
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_INFO: rmw_log_severity_t = 20;
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_WARN: rmw_log_severity_t = 30;
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_ERROR: rmw_log_severity_t = 40;
pub const rmw_log_severity_t_RMW_LOG_SEVERITY_FATAL: rmw_log_severity_t = 50;
pub type rmw_log_severity_t = ::std::os::raw::c_uint;
pub const rmw_event_type_e_RMW_EVENT_LIVELINESS_CHANGED: rmw_event_type_e = 0;
pub const rmw_event_type_e_RMW_EVENT_REQUESTED_DEADLINE_MISSED: rmw_event_type_e = 1;
pub const rmw_event_type_e_RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE: rmw_event_type_e = 2;
pub const rmw_event_type_e_RMW_EVENT_MESSAGE_LOST: rmw_event_type_e = 3;
pub const rmw_event_type_e_RMW_EVENT_LIVELINESS_LOST: rmw_event_type_e = 4;
pub const rmw_event_type_e_RMW_EVENT_OFFERED_DEADLINE_MISSED: rmw_event_type_e = 5;
pub const rmw_event_type_e_RMW_EVENT_OFFERED_QOS_INCOMPATIBLE: rmw_event_type_e = 6;
pub const rmw_event_type_e_RMW_EVENT_INVALID: rmw_event_type_e = 7;
pub type rmw_event_type_e = ::std::os::raw::c_uint;
pub use self::rmw_event_type_e as rmw_event_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_event_s {
    pub implementation_identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub event_type: rmw_event_type_t,
}
pub type rmw_event_t = rmw_event_s;
pub type rmw_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(user_data: *const ::std::os::raw::c_void, number_of_events: usize),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_sequence_s {
    pub data: *mut *mut ::std::os::raw::c_void,
    pub size: usize,
    pub capacity: usize,
    pub allocator: *mut rcutils_allocator_t,
}
pub type rmw_message_sequence_t = rmw_message_sequence_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmw_message_info_sequence_s {
    pub data: *mut rmw_message_info_t,
    pub size: usize,
    pub capacity: usize,
    pub allocator: *mut rcutils_allocator_t,
}
pub type rmw_message_info_sequence_t = rmw_message_info_sequence_s;
