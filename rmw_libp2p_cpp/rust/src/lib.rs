// Copyright 2024 Esteve Fernandez
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

mod bindings;
mod bindings_types;
mod rmw_get_serialization_format;

pub use bindings::*;
pub use bindings_types::*;
pub use rmw_get_serialization_format::*;

#[no_mangle]
pub static mut libp2p_identifier: *const ::std::os::raw::c_char =
    b"rmw_libp2p_rs\0".as_ptr() as *const ::std::os::raw::c_char;

#[no_mangle]
pub static mut libp2p_serialization_format: *const ::std::os::raw::c_char =
    b"cdr\0".as_ptr() as *const ::std::os::raw::c_char;

/* automatically generated by rust-bindgen 0.69.4 */

// #[no_mangle]
// pub extern "C" fn rmw_get_serialization_format() -> *const ::std::os::raw::c_char;

#[no_mangle]
pub extern "C" fn rmw_get_implementation_identifier() -> *const ::std::os::raw::c_char {
    unsafe { libp2p_c__rmw_get_implementation_identifier() }
}

#[no_mangle]
pub extern "C" fn rmw_create_node(
    context: *mut rmw_context_t,
    name: *const ::std::os::raw::c_char,
    namespace_: *const ::std::os::raw::c_char,
) -> *mut rmw_node_t {
    unsafe { libp2p_c__rmw_create_node(context, name, namespace_) }
}

#[no_mangle]
pub extern "C" fn rmw_destroy_node(node: *mut rmw_node_t) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_destroy_node(node) }
}

#[no_mangle]
pub extern "C" fn rmw_node_assert_liveliness(node: *const rmw_node_t) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_node_assert_liveliness(node) }
}

#[no_mangle]
pub extern "C" fn rmw_node_get_graph_guard_condition(
    node: *const rmw_node_t,
) -> *const rmw_guard_condition_t {
    unsafe { libp2p_c__rmw_node_get_graph_guard_condition(node) }
}

#[no_mangle]
pub extern "C" fn rmw_init_publisher_allocation(
    type_support: *const rosidl_message_type_support_t,
    message_bounds: *const rosidl_runtime_c__Sequence__bound,
    allocation: *mut rmw_publisher_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_init_publisher_allocation(type_support, message_bounds, allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_fini_publisher_allocation(
    allocation: *mut rmw_publisher_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_fini_publisher_allocation(allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_create_publisher(
    node: *const rmw_node_t,
    type_support: *const rosidl_message_type_support_t,
    topic_name: *const ::std::os::raw::c_char,
    qos_profile: *const rmw_qos_profile_t,
    publisher_options: *const rmw_publisher_options_t,
) -> *mut rmw_publisher_t {
    unsafe {
        libp2p_c__rmw_create_publisher(
            node,
            type_support,
            topic_name,
            qos_profile,
            publisher_options,
        )
    }
}

#[no_mangle]
pub extern "C" fn rmw_destroy_publisher(
    node: *mut rmw_node_t,
    publisher: *mut rmw_publisher_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_destroy_publisher(node, publisher) }
}

#[no_mangle]
pub extern "C" fn rmw_borrow_loaned_message(
    publisher: *const rmw_publisher_t,
    type_support: *const rosidl_message_type_support_t,
    ros_message: *mut *mut ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_borrow_loaned_message(publisher, type_support, ros_message) }
}

#[no_mangle]
pub extern "C" fn rmw_return_loaned_message_from_publisher(
    publisher: *const rmw_publisher_t,
    loaned_message: *mut ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_return_loaned_message_from_publisher(publisher, loaned_message) }
}

#[no_mangle]
pub extern "C" fn rmw_publish(
    publisher: *const rmw_publisher_t,
    ros_message: *const ::std::os::raw::c_void,
    allocation: *mut rmw_publisher_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_publish(publisher, ros_message, allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_publish_loaned_message(
    publisher: *const rmw_publisher_t,
    ros_message: *mut ::std::os::raw::c_void,
    allocation: *mut rmw_publisher_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_publish_loaned_message(publisher, ros_message, allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_publisher_count_matched_subscriptions(
    publisher: *const rmw_publisher_t,
    subscription_count: *mut usize,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_publisher_count_matched_subscriptions(publisher, subscription_count) }
}

#[no_mangle]
pub extern "C" fn rmw_publisher_get_actual_qos(
    publisher: *const rmw_publisher_t,
    qos: *mut rmw_qos_profile_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_publisher_get_actual_qos(publisher, qos) }
}

#[no_mangle]
pub extern "C" fn rmw_publish_serialized_message(
    publisher: *const rmw_publisher_t,
    serialized_message: *const rmw_serialized_message_t,
    allocation: *mut rmw_publisher_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_publish_serialized_message(publisher, serialized_message, allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_get_serialized_message_size(
    type_support: *const rosidl_message_type_support_t,
    message_bounds: *const rosidl_runtime_c__Sequence__bound,
    size: *mut usize,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_get_serialized_message_size(type_support, message_bounds, size) }
}

#[no_mangle]
pub extern "C" fn rmw_publisher_assert_liveliness(publisher: *const rmw_publisher_t) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_publisher_assert_liveliness(publisher) }
}

#[no_mangle]
pub extern "C" fn rmw_publisher_wait_for_all_acked(
    publisher: *const rmw_publisher_t,
    wait_timeout: rmw_time_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_publisher_wait_for_all_acked(publisher, wait_timeout) }
}

#[no_mangle]
pub extern "C" fn rmw_serialize(
    ros_message: *const ::std::os::raw::c_void,
    type_support: *const rosidl_message_type_support_t,
    serialized_message: *mut rmw_serialized_message_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_serialize(ros_message, type_support, serialized_message) }
}

#[no_mangle]
pub extern "C" fn rmw_deserialize(
    serialized_message: *const rmw_serialized_message_t,
    type_support: *const rosidl_message_type_support_t,
    ros_message: *mut ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_deserialize(serialized_message, type_support, ros_message) }
}

#[no_mangle]
pub extern "C" fn rmw_init_subscription_allocation(
    type_support: *const rosidl_message_type_support_t,
    message_bounds: *const rosidl_runtime_c__Sequence__bound,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_init_subscription_allocation(type_support, message_bounds, allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_fini_subscription_allocation(
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_fini_subscription_allocation(allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_create_subscription(
    node: *const rmw_node_t,
    type_support: *const rosidl_message_type_support_t,
    topic_name: *const ::std::os::raw::c_char,
    qos_policies: *const rmw_qos_profile_t,
    subscription_options: *const rmw_subscription_options_t,
) -> *mut rmw_subscription_t {
    unsafe {
        libp2p_c__rmw_create_subscription(
            node,
            type_support,
            topic_name,
            qos_policies,
            subscription_options,
        )
    }
}

#[no_mangle]
pub extern "C" fn rmw_destroy_subscription(
    node: *mut rmw_node_t,
    subscription: *mut rmw_subscription_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_destroy_subscription(node, subscription) }
}

#[no_mangle]
pub extern "C" fn rmw_subscription_count_matched_publishers(
    subscription: *const rmw_subscription_t,
    publisher_count: *mut usize,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_subscription_count_matched_publishers(subscription, publisher_count) }
}

#[no_mangle]
pub extern "C" fn rmw_subscription_get_actual_qos(
    subscription: *const rmw_subscription_t,
    qos: *mut rmw_qos_profile_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_subscription_get_actual_qos(subscription, qos) }
}

#[no_mangle]
pub extern "C" fn rmw_subscription_set_content_filter(
    subscription: *mut rmw_subscription_t,
    options: *const rmw_subscription_content_filter_options_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_subscription_set_content_filter(subscription, options) }
}

#[no_mangle]
pub extern "C" fn rmw_subscription_get_content_filter(
    subscription: *const rmw_subscription_t,
    allocator: *mut rcutils_allocator_t,
    options: *mut rmw_subscription_content_filter_options_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_subscription_get_content_filter(subscription, allocator, options) }
}

#[no_mangle]
pub extern "C" fn rmw_take(
    subscription: *const rmw_subscription_t,
    ros_message: *mut ::std::os::raw::c_void,
    taken: *mut bool,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_take(subscription, ros_message, taken, allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_take_with_info(
    subscription: *const rmw_subscription_t,
    ros_message: *mut ::std::os::raw::c_void,
    taken: *mut bool,
    message_info: *mut rmw_message_info_t,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_take_with_info(subscription, ros_message, taken, message_info, allocation)
    }
}

#[no_mangle]
pub extern "C" fn rmw_take_sequence(
    subscription: *const rmw_subscription_t,
    count: usize,
    message_sequence: *mut rmw_message_sequence_t,
    message_info_sequence: *mut rmw_message_info_sequence_t,
    taken: *mut usize,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_take_sequence(
            subscription,
            count,
            message_sequence,
            message_info_sequence,
            taken,
            allocation,
        )
    }
}

#[no_mangle]
pub extern "C" fn rmw_take_serialized_message(
    subscription: *const rmw_subscription_t,
    serialized_message: *mut rmw_serialized_message_t,
    taken: *mut bool,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_take_serialized_message(subscription, serialized_message, taken, allocation)
    }
}

#[no_mangle]
pub extern "C" fn rmw_take_serialized_message_with_info(
    subscription: *const rmw_subscription_t,
    serialized_message: *mut rmw_serialized_message_t,
    taken: *mut bool,
    message_info: *mut rmw_message_info_t,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_take_serialized_message_with_info(
            subscription,
            serialized_message,
            taken,
            message_info,
            allocation,
        )
    }
}

#[no_mangle]
pub extern "C" fn rmw_take_loaned_message(
    subscription: *const rmw_subscription_t,
    loaned_message: *mut *mut ::std::os::raw::c_void,
    taken: *mut bool,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_take_loaned_message(subscription, loaned_message, taken, allocation) }
}

#[no_mangle]
pub extern "C" fn rmw_take_loaned_message_with_info(
    subscription: *const rmw_subscription_t,
    loaned_message: *mut *mut ::std::os::raw::c_void,
    taken: *mut bool,
    message_info: *mut rmw_message_info_t,
    allocation: *mut rmw_subscription_allocation_t,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_take_loaned_message_with_info(
            subscription,
            loaned_message,
            taken,
            message_info,
            allocation,
        )
    }
}

#[no_mangle]
pub extern "C" fn rmw_return_loaned_message_from_subscription(
    subscription: *const rmw_subscription_t,
    loaned_message: *mut ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_return_loaned_message_from_subscription(subscription, loaned_message) }
}

#[no_mangle]
pub extern "C" fn rmw_create_client(
    node: *const rmw_node_t,
    type_support: *const rosidl_service_type_support_t,
    service_name: *const ::std::os::raw::c_char,
    qos_policies: *const rmw_qos_profile_t,
) -> *mut rmw_client_t {
    unsafe { libp2p_c__rmw_create_client(node, type_support, service_name, qos_policies) }
}

#[no_mangle]
pub extern "C" fn rmw_destroy_client(
    node: *mut rmw_node_t,
    client: *mut rmw_client_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_destroy_client(node, client) }
}

#[no_mangle]
pub extern "C" fn rmw_send_request(
    client: *const rmw_client_t,
    ros_request: *const ::std::os::raw::c_void,
    sequence_id: *mut i64,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_send_request(client, ros_request, sequence_id) }
}

#[no_mangle]
pub extern "C" fn rmw_take_response(
    client: *const rmw_client_t,
    request_header: *mut rmw_service_info_t,
    ros_response: *mut ::std::os::raw::c_void,
    taken: *mut bool,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_take_response(client, request_header, ros_response, taken) }
}

#[no_mangle]
pub extern "C" fn rmw_client_request_publisher_get_actual_qos(
    client: *const rmw_client_t,
    qos: *mut rmw_qos_profile_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_client_request_publisher_get_actual_qos(client, qos) }
}

#[no_mangle]
pub extern "C" fn rmw_client_response_subscription_get_actual_qos(
    client: *const rmw_client_t,
    qos: *mut rmw_qos_profile_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_client_response_subscription_get_actual_qos(client, qos) }
}

#[no_mangle]
pub extern "C" fn rmw_create_service(
    node: *const rmw_node_t,
    type_support: *const rosidl_service_type_support_t,
    service_name: *const ::std::os::raw::c_char,
    qos_profile: *const rmw_qos_profile_t,
) -> *mut rmw_service_t {
    unsafe { libp2p_c__rmw_create_service(node, type_support, service_name, qos_profile) }
}

#[no_mangle]
pub extern "C" fn rmw_destroy_service(
    node: *mut rmw_node_t,
    service: *mut rmw_service_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_destroy_service(node, service) }
}

#[no_mangle]
pub extern "C" fn rmw_take_request(
    service: *const rmw_service_t,
    request_header: *mut rmw_service_info_t,
    ros_request: *mut ::std::os::raw::c_void,
    taken: *mut bool,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_take_request(service, request_header, ros_request, taken) }
}

#[no_mangle]
pub extern "C" fn rmw_send_response(
    service: *const rmw_service_t,
    request_header: *mut rmw_request_id_t,
    ros_response: *mut ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_send_response(service, request_header, ros_response) }
}

#[no_mangle]
pub extern "C" fn rmw_service_request_subscription_get_actual_qos(
    service: *const rmw_service_t,
    qos: *mut rmw_qos_profile_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_service_request_subscription_get_actual_qos(service, qos) }
}

#[no_mangle]
pub extern "C" fn rmw_service_response_publisher_get_actual_qos(
    service: *const rmw_service_t,
    qos: *mut rmw_qos_profile_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_service_response_publisher_get_actual_qos(service, qos) }
}

#[no_mangle]
pub extern "C" fn rmw_create_guard_condition(
    context: *mut rmw_context_t,
) -> *mut rmw_guard_condition_t {
    unsafe { libp2p_c__rmw_create_guard_condition(context) }
}

#[no_mangle]
pub extern "C" fn rmw_destroy_guard_condition(
    guard_condition: *mut rmw_guard_condition_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_destroy_guard_condition(guard_condition) }
}

#[no_mangle]
pub extern "C" fn rmw_trigger_guard_condition(
    guard_condition: *const rmw_guard_condition_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_trigger_guard_condition(guard_condition) }
}

#[no_mangle]
pub extern "C" fn rmw_create_wait_set(
    context: *mut rmw_context_t,
    max_conditions: usize,
) -> *mut rmw_wait_set_t {
    unsafe { libp2p_c__rmw_create_wait_set(context, max_conditions) }
}

#[no_mangle]
pub extern "C" fn rmw_destroy_wait_set(wait_set: *mut rmw_wait_set_t) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_destroy_wait_set(wait_set) }
}

#[no_mangle]
pub extern "C" fn rmw_wait(
    subscriptions: *mut rmw_subscriptions_t,
    guard_conditions: *mut rmw_guard_conditions_t,
    services: *mut rmw_services_t,
    clients: *mut rmw_clients_t,
    events: *mut rmw_events_t,
    wait_set: *mut rmw_wait_set_t,
    wait_timeout: *const rmw_time_t,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_wait(
            subscriptions,
            guard_conditions,
            services,
            clients,
            events,
            wait_set,
            wait_timeout,
        )
    }
}

#[no_mangle]
pub extern "C" fn rmw_get_node_names(
    node: *const rmw_node_t,
    node_names: *mut rcutils_string_array_t,
    node_namespaces: *mut rcutils_string_array_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_get_node_names(node, node_names, node_namespaces) }
}

#[no_mangle]
pub extern "C" fn rmw_get_node_names_with_enclaves(
    node: *const rmw_node_t,
    node_names: *mut rcutils_string_array_t,
    node_namespaces: *mut rcutils_string_array_t,
    enclaves: *mut rcutils_string_array_t,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_get_node_names_with_enclaves(node, node_names, node_namespaces, enclaves)
    }
}

#[no_mangle]
pub extern "C" fn rmw_count_publishers(
    node: *const rmw_node_t,
    topic_name: *const ::std::os::raw::c_char,
    count: *mut usize,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_count_publishers(node, topic_name, count) }
}

#[no_mangle]
pub extern "C" fn rmw_count_subscribers(
    node: *const rmw_node_t,
    topic_name: *const ::std::os::raw::c_char,
    count: *mut usize,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_count_subscribers(node, topic_name, count) }
}

#[no_mangle]
pub extern "C" fn rmw_get_gid_for_publisher(
    publisher: *const rmw_publisher_t,
    gid: *mut rmw_gid_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_get_gid_for_publisher(publisher, gid) }
}

#[no_mangle]
pub extern "C" fn rmw_compare_gids_equal(
    gid1: *const rmw_gid_t,
    gid2: *const rmw_gid_t,
    result: *mut bool,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_compare_gids_equal(gid1, gid2, result) }
}

#[no_mangle]
pub extern "C" fn rmw_service_server_is_available(
    node: *const rmw_node_t,
    client: *const rmw_client_t,
    is_available: *mut bool,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_service_server_is_available(node, client, is_available) }
}

#[no_mangle]
pub extern "C" fn rmw_set_log_severity(severity: rmw_log_severity_t) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_set_log_severity(severity) }
}

#[no_mangle]
pub extern "C" fn rmw_subscription_set_on_new_message_callback(
    subscription: *mut rmw_subscription_t,
    callback: rmw_event_callback_t,
    user_data: *const ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe {
        libp2p_c__rmw_subscription_set_on_new_message_callback(subscription, callback, user_data)
    }
}

#[no_mangle]
pub extern "C" fn rmw_service_set_on_new_request_callback(
    service: *mut rmw_service_t,
    callback: rmw_event_callback_t,
    user_data: *const ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_service_set_on_new_request_callback(service, callback, user_data) }
}

#[no_mangle]
pub extern "C" fn rmw_client_set_on_new_response_callback(
    client: *mut rmw_client_t,
    callback: rmw_event_callback_t,
    user_data: *const ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_client_set_on_new_response_callback(client, callback, user_data) }
}

#[no_mangle]
pub extern "C" fn rmw_event_set_callback(
    event: *mut rmw_event_t,
    callback: rmw_event_callback_t,
    user_data: *const ::std::os::raw::c_void,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_event_set_callback(event, callback, user_data) }
}

#[no_mangle]
pub extern "C" fn rmw_init_options_init(
    options: *mut rmw_init_options_t,
    allocator: rcutils_allocator_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_init_options_init(options, allocator) }
}

#[no_mangle]
pub extern "C" fn rmw_init_options_copy(
  src: *const rmw_init_options_t,
  dst: *mut rmw_init_options_t,
) -> rmw_ret_t {
    unsafe { libp2p_c__rmw_init_options_copy(src, dst) }
}
